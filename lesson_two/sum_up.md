## 1.所有权

1. 所有权规则：在 Rust 中，每个值都有一个**唯一**的所有者，该所有者是一个绑定到该值的变量。这个所有者负责分配和释放值所占用的内存。
2. 作用域：每个值都有其作用域，它定义了该值在程序中的**可见性**范围。当变量超出其作用域时，该值的所有权将被释放，并且其占用的内存将被回收。
3. 所有权转移：所有权可以通过赋值操作或函数调用来转移。当将一个值赋给另一个变量或将其传递给函数时，所有权将从一个变量转移到另一个变量。这确保了在编译时只有一个所有者可以修改或释放该值。
4. 所有权和移动语义：对于一些类型，例如包含堆分配资源的类型（如字符串），它们的所有权是不可复制的。当将这些类型的值赋给其他变量时，所有权将从一个变量移动到另一个变量，而不是进行复制。
5. 借用：为了在不转移所有权的情况下对值进行访问，Rust 提供了借用机制。借用通过引用来访问值，而不获取其所有权。借用有两种类型：**不可变引用和可变引用。**
6. 引用的作用域：引用的作用域是从其定义开始到其**最后一次使用**为止。在这个范围内，引用是有效的。一旦引用超出其作用域，它将不再有效。
7. 可变引用的**排它性**：Rust 的借用规则确保同一时间内只能有一个可变引用存在。这样可以避免数据竞争和保证内存安全。

## 2.不可变引用

- 不可变引用使用 `&` 符号声明，允许对值进行**只读**访问，但不能修改它。
- 不可变引用使**多个**代码块可以同时访问值，而不会发生数据竞争。

```rust
let a = 10;
let b = &a;
*b = 1; // &a是 不可变引用 所以b是无法修改的
println!("{b}");
```

## 3.可变引用

- 可变引用使用 `&mut` 符号声明，允许对值进行读写访问。
- 同一时间内最多**只能有一个**可变引用， 并且在该作用域内它是唯一引用并且具有对值的独占访问权。 
  避免了多线程下的数据竞争。

```Rust
fn str_push(s: &mut String) {
    s.push_str("Rust");
}

fn main() {
    // 注意s 必须是可变的（mut）下文才可以使用可变引用
    let mut s = String::from("Hello");
    // &mut s表示可变引用 可以修改数据
    str_push(&mut s);

    println!("{s}") // HelloRust
}
```

存在多个可变引用编译不过

```rust
fn main() {
    let mut s = "Hello";
    let s1 = &mut s;
    let s2 = &mut s; //^^^^^^ second mutable borrow occurs here
    println!("{s1}");
    println!("{s2}");
}
```



## 4.引用的作用域

- 一个拥有所有权的变量的作用域是从它定义时到花括号结束
- 引用的作用域是从它定义到它**最后一次使用时结束**

```rust
fn main() {
    let mut a = "Hello";
    let mut b = &mut a;
    let c = &mut b;

    println!("{b}"); // 最后一次使用 之后失效
    println!("{c}"); // b失效了 c引用失败报错
}
```

## 5.可变引用的排它性

- 不可变引用可以被复制

```rust
fn main() {
    let s = "Hello";
    let s1 = &s;
    let s2 = s1;
    println!("s1=={s1}"); // s1==Hello
    println!("s2=={s2}");// s2==Hello
}
```

- 可变引用不能被复制，只能被move

```rust
fn main() {
    let mut s = "Hello Rust";
    let s1 = &mut s;
    let s2 = s1; // s1 move所有权转移了s2 所以下文使用s1报错
    println!("{s1}");
    println!("{s2}");
}
```

